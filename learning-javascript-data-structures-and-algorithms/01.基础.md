# 01.基础

前三章都是介绍基础，方便没学过 JavaScript 的其他语言开发者也能读懂本书。所以对于前端开发者，基本可以直接跳过。

这里我只记录遗忘了的几个小细节

### 1. 位运算

有点遗忘补码的规则了，所以看到取非运算符时重新复习了下
```
console.log(~5); 
```
JavaScript 使用 64 位双精度浮点型表示数字，那么 5 的二进制表示是 `0000 .... 0000 0101`，取非后是 `1111 .... 1111 1010`

这显然是个负数，但是是负多少呢？

负数的二进制表示是其绝对值的补码，而计算补码的方式是先取反，再+1。所以其对应的绝对值是

`取反(1111 .... 1111 1010 - 1)` => `取反(1111 .... 1111 1001)` => `0000 ... 0000 0110` 即 6

因此 `~5` 的值是 -6

对于非科班出身的开发者，可以看看阮老师的科普文 [关于2的补码](http://www.ruanyifeng.com/blog/2009/08/twos_complement.html)




### 2. 相等运算符

```
console.log('packet' ? true : false) // {1}
console.log('packet' == true)        // {2}
console.log('packet' == false)       // {3}
```

会输出什么？

```
true
false
false
```

为什么呢？
对于行{1}，在条件运算符或 if 条件语句中，当条件值是 trusy 的，则进入第一个分支；而条件值是 falsy 的，则进入第二个分支。除了 `false`, `0`, `-0`, `0n`, `""`, `null`, `undefined`,  `NaN` 是 falsy 值以外，其他的都是 trusy 值。因此结果是 true

而对于行{2}，我们都知道相等运算符会进行隐式转换，而在布尔值和任何类型进行比较时，会将布尔值转换为数值后进行比较，
也就是 `'packet' == 1`；

对字符串和数值进行比较时，又会将字符串转换为数值。即 `NaN == 1`，那结果自然就是 `false` 了。

行 {3} 同理。

我们并不需要记住具体的转换规则，唯一需要注意的是，由于隐式转换的存在，我们需要确保我们在条件判断时，以更精确的方式判断，避免发生不符合预期的事情。

比如判断函数参数是否存在时，应该用
`if(params !== undefined)` 而不是 `if(params)`；

条件表达式也是同理，不要随便用 `a && b` 或 `a || b` 或 `a ? 1 : 2`。
在进行比较时，应该使用 `===` 比较，而不是 `==`。

我在 code review 过程中就经常看到不严谨的判断 和 非全等的比较 以及其可能导致的问题。

另外，ES6 语法中的函数参数默认值

```
function test(a = 1){}
```

转换为 ES5 的语法其实就是判断 `undefined`
```
function test(){
    var a = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 3;
}
```

这里附上不同类型的值用相等运算符比较后的结果。

| 类型（`x`）  | 类型（`y`）  | 结果                    |
|:------------|:------------|:-----------------------|
| `null`      | `undefined` | `true`                 |
| `undefined` | `null`      | `true`                 |
| 数          | 字符串       | `x == toNumber(y)`     |
| 字符串       | 数          | `toNumber(x) == y`     |
| 布尔值       | 任何类型     | `toNumber(x) == y`     |
| 任何类型     | 布尔值       | `x == toNumber(y)`     |
| 字符串或数   | 对象         | `x == toPrimitive(y)`  |
| 对象         | 字符串或数   | `toPrimitive(x) == y`  |

`toNumber`方法对不同类型返回的结果如下。

| 值类型       | 结果                                         |
|:------------|:--------------------------------------------|
| `undefined` | `NaN`                                       |
| `null`      | `+0`                                        |
| 布尔值       | 如果是`true`，返回`1`；如果是`false`，返回`+0` |
| 数          | 数对应的值                                   |

`toPrimitive`方法对不同类型返回的结果如下。

| 值类型 | 结果                                                                                                           |
|:------|:---------------------------------------------------------------------------------------------------------------|
| 对象   | 如果对象的`valueOf`方法的结果是原始值，返回原始值；如果对象的`toString`方法返回原始值，就返回这个值；其他情况都返回一个错误 |



### 3. TypeScript
Typescript 的接口和私有属性等特性在开发数据结构和排序算法时很有用，但我对 typescript 的熟悉度不够（T_T），所以在此先记录个 Todo：使用 TypeScript 来写算法。
（作者的代码仓库中有 typescript 版本的实现）

### 4.数组

数组包含的内容也比较少，因此不单独写了

1. 各种数组方法及其实现

参考 lodash 的实现


1. 斐波那契数列（的迭代实现）


2. 类型数组

