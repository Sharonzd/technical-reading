# 第7章 HTTP 缓存

# 缓存的优点

1. 能减少冗余的数据传输，节省网络费用
2. 缓解网络瓶颈问题，使得更快的加载页面
3. 降低了对原始服务器的要求，能够避免特殊事件造成网络瞬间拥塞甚至崩溃
4. 能够降低距离造成的网络延时

# 缓存相关的名词解释

**Web 缓存**：自动保存常见文档副本的 HTTP 设备，包括私有缓存和公有代理缓存。
- 私有缓存比如浏览器使用磁盘和内存作为缓存空间；
- 公有缓存是指共享的代理缓存服务器，也称为代理缓存。

**缓存命中**：用已有的副本为某些到达缓存的请求提供服务。
**缓存未命中**：到达缓存的请求由于没有可用的副本，从而被转发给原始服务器。
**HTTP 再验证**：缓存时不时的去访问服务器，来检测缓存中保存的副本是否是最新的。（但是由于频繁检测很耗费网络，所以大部分缓存只有在客户端发起请求，并且满足需要检测的规则的时候，才会去验证）
**再验证命中/缓慢命中**：当缓存向原始服务器发送再验证请求时，服务器返回304，告知内容没有变化。
**缓存命中率/文档命中率**：由缓存提供服务的请求所占的比例。（由于每个请求都会占用固定的连接时延，所以提高文档命中率可以降低整体时延）
**字节命中率**：缓存提供的字节在传输的所有字节中所占的比例。（因为可能某个比较大的文档，虽然访问次数少，但是对流量贡献很大，所以统计字节命中率可以节省带宽）

### 问：怎么判断一个请求是否命中缓存？

如果发起一个请求，并且成功响应时，不管是缓存命中的，还是访问原始服务器得到的，响应码都是 200 OK。
这种情况下，有以下几种方式判断请求是否命中缓存。
一是可以查看 response 的 header 中的 Date 首部，是否是比当前日期早，如果比现在早，就可以证明是缓存。因为 Date 首部是报文创建的日期和时间。比如下图中的 date 就证明是缓存。
二是可以查看 response 的 header 中的 Age 首部，如果比较长也证明是缓存。因为 age 首部是 HTTP/1.1 规定的缓存必须在每条响应中用来告诉客户端这个响应已经产生了多长时间，单位是 s。如下图的 age 是 175214 = 48.6h，理论上 age 应该等于当前时间 减去 date 时间，但是由于时钟的差异等各种原因不准，有更复杂的计算规则，后续再讲。

![%E7%AC%AC7%E7%AB%A0%20HTTP%20%E7%BC%93%E5%AD%98%20c70dc12283b940e1b69aab0703e6b06d/Untitled.png](%E7%AC%AC7%E7%AB%A0%20HTTP%20%E7%BC%93%E5%AD%98%20c70dc12283b940e1b69aab0703e6b06d/Untitled.png)

# 代理缓存的结构

在实际场景中，代理缓存一般会被实现为多层次的，结构是：
客户端缓存 -> 一级缓存 -> 二级缓存 -> 原始服务器。

在未命中缓存的情况下会继续导向更大、功能更强、成本也更高的父缓存。
在复杂场景中，代理缓存会被实现为网状缓存。代理缓存之间会动态的决定走向哪个父缓存或者走向原始服务器，这种结构中，代理缓存也被称为内容路由器。

# 缓存的处理步骤

1. 从网络中**接收**客户端的 HTTP 请求报文
2. **解析**报文的 URL 和首部
3. **查询**本地是否有可用的副本，没有则从服务器获取并保存在本地
4. 对于已有的可用副本，**检测**其是否新鲜，不新鲜的话就请求服务器，查询是否有更新
5. 用新的首部和缓存的主体**创建**一条**响应**报文
6. 通过网络将响应**发回**给客户端
7. 创建一个**日志**描述这个事务过程

# HTTP 缓存相关的首部

## 验证文档过期（也被业界称为强制缓存）

服务器使用 HTTP/1.0+的 Expires 首部和 HTTP/1.1 的 Cache-Control: max-age 响应首部来指定过期日期。前者指定的是绝对日期（依赖于计算机的时钟），而后者指定的是相对日期，所以使用 Cache-Control 更靠谱。

## 使用条件方法再验证（也被业界称为协商缓存）

缓存会向原始服务器发一个条件 GET 请求，只有条件为真时，服务器才返回主体。
条件首部中常用于缓存的两个是 If-Modified-Since:<date> 和 If-None-Match:<tags>
- If-Modified-Since 请求首部通常和 Last-Modified 响应首部配套使用，也就是说，缓存发送的 If-Modified-Since 值为该文档的之前的 Last-Modified 日期。
- If-None-Match 通常和 Etag 配合使用。它存在的意义是，仅仅使用修改日期来验证缓存是否过期是不够的，比如有可能某个文件内容没变化，但是被重写了，日期也变了；比如某些注释的修改造成的日期改变也不重要；比如某个文档可能在一秒内改变了，但是日期由于是以秒为单位，因此没有修改日期。所以 ETag 就是作为版本标识符，来从文件层面来标识文档的版本。

出于性能和灵活考虑，对于某些不重要的修改，服务器可以用前缀 W/ 标识弱验证器（Etag: W/"v2.6"    If-None-Match: W/"v2.6"）。从而不必更新缓存。没这个标识的就是强实体标签，无论发生了什么修改，强实体标签都需要变化。

优先使用实体标签（ETag）作为条件方法再验证的方式。

## 服务器用于控制缓存的响应首部

Cache-Control: no-store	           禁止缓存对复制和存储响应
Cache-Control: no-cache	（与字面意思有差别）允许缓存存储响应，但是必须进行再验证后才能给客户端使用。（无论过没过期，都得再验证）
Cache-Control: must-revalidate	要求缓存没有进行再验证的话，不能给客户端提供旧的副本。（也就是说对于过期了的情况，必须进行再验证。注意与 no-cache 的差别）
Cache-Control: max-age=xx	响应主体的最大使用期限，单位为秒。如果设置为0，代表不要缓存文档。
Expires	过期的绝对日期，由于很多服务器时钟不同步，因此不推荐使用

## 试探性过期的 LM-Factor 算法

对于没有 Cache-Control: max-age 和 Expires 首部，但是有最后修改日期的情况，缓存只能用算法试探性的计算过期时间。LM-Factor 算法是使用距离上次修改的日期的时间间距 乘以 一个(0,1)之间的因子，作为新的过期时间周期。
该算法的原理是，如果已缓存文档的最后修改时间很早的话，那应该就是一份稳定的文档（因子会设大一点）；否则如果最近就被修改过，那它可能更新很频繁（因子会设小一点）。

如果连 Last-modified 信息都没有的话，缓存就会设一个默认的新鲜周期，比如1h 或者1day，或者干脆设为0，每次客户端访问时，缓存都进行再验证。

## 客户端用于控制缓存的请求首部

Cache-Control: max-stale	缓存可以提供过期的文件也没关系（更宽松的要求）
Cache-Control: max-stale=<s>	在这段时间内过期的文档都可以（更宽松的要求）
Cache-Control: min-refresh=<s>	至少在未来 s 秒内文档都得是新鲜的，才能用缓存（更严格的要求）
Cache-Control: max-age=<s>	缓存不能返回缓存时间超过了 s 秒的文档（更严格的要求）
Cache-Control: no-cache	除非你进行了再验证，否则我不接受已缓存的资源
Pragma: no-cache	同上，HTTP/1.0+ 版本的
Cache-Control: no-store	你不能缓存这份文档，有的话赶紧删掉
Cache-Control: only-if-cached	只有你缓存了副本的情况下，才需要返回给我（否则就不需要）

## 缓存的利弊

显而易见，缓存好处多多（提高性能，节约流量）。但是有一个角色会因为缓存而苦恼，---- 那就是投放了按访问次数收费的广告的内容提供商，因为访问都流量都被缓存拦截住了，那他的广告收入就很惨了。
对此提供商的服务器不得不使用各种方式来解决，一种简单粗暴的是配置 no-store 禁用缓存，或者使用 no-cache 来要求缓存必须再验证，但这样会损失缓存带来的好处。另外一种是让缓存把命中日志发回给服务器，但这个日志很庞大，而且不够标准化。更简单易用的方式是定义在 RFC 2227的“HTTP 的简单命中计数和使用限制”的方案，新增了 Meter 首部，用于周期性地将特定 URL 的命中次数回送给服务器。