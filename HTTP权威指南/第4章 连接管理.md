# 第4章 连接管理

# HTTP 如何使用 TCP 连接？

今天分享 HTTP 和 TCP 的关系：

我们知道五层模型的网络协议栈分为应用层，传输层，网络层，数据链路层和物理层。

而HTTP属于应用层协议，TCP属于传输层，IP属于网络层。所以 HTTP 其实就是 HTTP over TCP over IP 的协议栈的顶层，而 HTTPS 就是 HTTP 和 TCP 之间插入了一个TLS 传输层安全协议或 SSL安全套接字层 的密码加密层。

当HTTP 要发送报文时，会以流的形式将报文数据内容通过一条打开的 TCP 连接按序传输，然后 TCP 会将数据流分为称作段的小数据块，并将段封装在 IP 分组中，通过因特网进行传输。

# TCP 的性能

今天分享 HTTP 连接的性能相关

一个 HTTP 请求和响应包含以下6个步骤，根据这6个步骤，分别讲一下其中可能产生的性能影响

**1. DNS 查询**

性能影响：DNS 查询耗时，现在 HTTP 客户端通常有 DNS 缓存来避免查询耗时

**1. 建立连接（发送 TCP 连接请求，并等待服务器返回一个请求接受应答）**

性能影响：

1. TCP 连接建立握手：分别要传输分别带有 SYN 和 ACK 信息的两个分组才能建立连接，如果实际上要传的数据很小就很不划算了
    1. SYN
    2. SYN+ACK
    3. ACK + 请求
2. TCP 延迟确认： ACK 信息会等待着数据来捎带着自己和它们组合在一起传送，以减少协议的开销（因为每个段都有40+字节的标记和首部），但会导致延迟。

**1. 通过 TCP 管道发送 HTTP 请求**

性能影响：

1. TCP 慢启动拥塞控制：先限制速度，数据传输成功才逐渐提速，用于防止因特网的突然过载和拥塞
2. Nagle 算法：在发数据时等其他数据一起凑够一个大分组了才发送，跟 TCP 延迟确认 互相等待，导致了延迟。

**1. 服务器处理请求
2. 服务器回传 HTTP 响应**

同上述的数据传输

**1. 关闭 TCP 连接**

性能影响：

端口耗尽：关闭 TCP 连接时， 端口信息会保存 2min 中，重新连接都会使用新的端口，避免之前的分组被错误的放到新连接的 TCP 流中（以前网速慢）。但由于端口不能及时重用，导致端口可能会被耗尽。

**# HTTP 连接的性能优化手段**

**## 并行连接**

客户端打开多条连接，并行地执行多个 HTTP 事务，可能带来性能提升，减少总耗时。

但是并行多个连接会消耗很多内存资源，而且由于总带宽有限，所以一般会限制不超过4个并行连接。

此外并行连接仍然是每个事务都会打开或关闭一条新的连接，会耗费时间，也都会分别受 TCP 慢启动的特性的影响。

## 持久连接

在 HTTP 事务处理结束后仍然将 TCP 连接保持在打开状态，以便为未来的 HTTP 请求重用现存的连接，直到客户端或服务器将其关闭。以避免每次建立连接的时间消耗以及慢启动的请求和响应的时间消耗  。

持久连接分两种：HTTP/1.0+keep-alive连接，及 HTTP/1.1+persisten连接

### Keep-alive:

客户端发起请求首部包含 Connection: Keep-Alive，并且将连接保持打开状态。作为响应，服务器发 回一个带有 Connection: Keep-Alive 首部的报文，但如果服务器没法，客户端就认为服务端不支持 keep-alive 然后关闭连接。

响应中还可以包含 keep-alive 字段，用来表示服务器可以保持连接的时间和数量。比如

Connection: Keep-Alive

Keep-Alive: max=5, timeout=120

代表服务器最多还会为另5个事务保持连接的打开状态，会将打开状态保持2min

问题：客户端和服务器之间经常会有代理，而代理不一定支持 keep-alive，但它会传送 keep-alive 的头部使得客户端和服务器误以为对方是开放连接的，但是代理却在完成请求和响应的中转后关闭了连接，这样客户端和服务器就一直挂起了，直到超时。

为了解决这个问题，网景浏览器涉及了 Proxy-Connection 头部，支持 keep-alive 的代理能识别 Proxy-Connection，并将其转成 Connection 发给服务端，从而实现开放连接，不支持 keep-alive 的代理就直接透传 Proxy-Connection 头部，也不会产生挂起了。但对于有多重代理，并且多重代理中只要有一个代理是不支持 keep-alive 的，就仍然会出现上述的挂起问题。

### 持久连接：

HTTP1.1默认所有连接都是持久的，要在事务处理结束后用一个Connection: close 首部用来显示关闭连接。

当然服务端和客户端还是可以关闭空闲连接的，所以客户端需要有恢复请求的重试机制。而且一般最多维护两条持久连接，避免服务器过载。

## 管道化连接

在持久连接的基础上，管道链接是指不等响应返回就继续发送第二条请求、第三条请求，这样可以节约掉等待响应的时间，但是这样做也有风险，就是可能服务器收到数据后就关闭连接了，这样就会有发出去的连接无法到达的风险，所以客户端必须要有重试机制，这也是为什么管道化连接时不能发 POST 请求的原因，因为 POST 是非幂等请求，重新执行可能会带来副作用。

## 复用的连接