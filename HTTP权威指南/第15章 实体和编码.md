# 第15章 实体和编码

## HTTP 报文的目标：

需要保证它所传送的媒体对象：

- 可以被正确地识别，以便浏览器和其他客户端能正确处理内容（ Content-Type 、 Content-Language）
- 可以被正确地解包（Content-Length 、Content-Encoding）
- 是最新的（实体验证码 、缓存过期控制）
- 符合用户的需要（基于 Accept 系列的内容协商首部）
- 在网络上可以快速有效地传输（范围请求、差异编码及其他数据压缩方法）
- 完整到达、未被篡改（传输编码首部、Content-MD5 校验和首部）

## 带着疑问来阅读

- HTTP 报文实体有哪些格式和行为？
- HTTP 如何描述实体的主体大小？为确定大小制定了哪些规则？
- 为了使得客户端正确处理内容，HTTP 使用了哪些实体首部来描述内容的格式、字母和语言？
- 什么是可逆的内容编码？使得发送方可以在发送之前用它来转换内容的数据格式，使其体积更小，更安全。
- 什么是传输编码和分块编码？
    - 传输编码可以改变 HTTP 传输数据的方式，以改善某些类型内容的通信能力
    - 分块编码是一种特殊的传输编码，它把数据切分城若干块，以更可靠地传输长度未知的内容。
- 有哪些能用来帮助客户端获取所请求内容最新版本的机制？
    - 标记、标签、时间、校验和、控制对象新鲜度的各种 HTTP 首部字段 等
- 什么是实体验证码？
    - 可以用作内容版本号，网站应用可以通过它确保接收最新的内容。
- 什么是范围？
    - 能用来恢复中断的传输
- 什么是差异编码？
    - 能使得客户端只需要请求网页中和前一次相比有改变的部分
- 什么是实体主体的校验和
    - 能用来检测经过若干代理后，实体的内容是否发生了改变

## 实体

实体分为**实体首部** 和 **实体主体**，由一个空行（CRLF）分隔。实体主体是 紧跟在 CRLF 之后的原始内容，比如文本、二进制内容、文档、图像、压缩或为压缩的、不同语言的内容。

> 打个比喻：HTTP 是货车，报文是货车上的集装箱，实体是集装箱里的货物，而实体首部是货物清单信息，实体主体则是原始货物

## 实体首部

### 媒体类型

- Content-Type
    - 概念：实体主体的 MIME 类型（基本媒体类型，由 IANA 注册，格式为 <主媒体/子类型>），而且是**编码前**的原始实体主体媒体类型。
    - 可选参数： 进一步说明内容类型的参数，比如 charset（字符编码）`Content-Type: text/html; charset=ios-8895-4`

### 实体大小

- Content-Length：
    - 概念：实体主体的字节大小，而且是**编码后**的大小，比如如果 gzip 压缩了，该首部值就是压缩后的大小。（而且没有首部说明编码前的大小，导致客户端难以确认解码是否完整）。
    - 是否必传：除非使用了分块编码，否则有实体主体的话，Content-Length 就必传。
    - 作用：
        - 使用 Content-Length 能检测出服务器崩溃导致的报文截尾（没有 Content-Length 的话，连接关闭后，接收方没办法判断是报文结束了，还是服务器崩溃中断了。那这种情况就不知道该不该使用这个报文，缓存代理服务器也不知道该不该缓存这个报文）
        - 使用 Content-Length 能对共享持久连接的多个报文进行正确分段。（对于持久连接的情况，收到一条 HTTP 响应后可能还会接着再收到一个响应，如果没有 Content-Length，客户端就不知道某个主体什么时候发完了，也不知道下一个报文什么时候开始。（特殊情况：用了分块编码的时候，可以没有 Content-Length，因为每个块都有大小说明））
    - 如何确认主体长度
        1. 对于不允许带有主体的报文，则忽略 Content-Length 首部。如 HEAD 响应
        2. 如果报文中有 Transfer-Encoding 首部，则忽略 Content-Length，实体遇到“零字节块”则结束
        3. 如果报文含有 Content-Length 首部，且不属于 1 2 的情况，那它的值就是主体长度。
        4. 如果没有 Content-Length ，但报文使用了 multipart/byteranges 媒体类型，那多不分报文中的每个部分自己说明自己的大小
        5. 如果不符合上述 1 2 3 4情况，则在连接关闭的时候，视为主体结束。

### 内容编码

内容编码是对报文主体进行的可逆变换。

- Content-Encoding
    - 概念：内容编码类型，用于指明内容的压缩或者加密方式。（由 IANA 机构注册，比如gzip、compress、deflate、identify 等）
- Accept-Encoding：
    - 与 Content-Encoding 配合使用的，客户端用来声明它支持什么编码方式。没有该首部的时候，相当于 Accept-Encoding: * ，代表能接收任何编码方式。
    - 语法是：“，”分割不同的支持编码，“q”质量参数Q 值说明编码优先级，Q 值范围为 0-1，值越大优先级越高
    - 举例：`Accept-Encoding: gzip;q=1.0, identify;q=0.5, *;q=0`

### 传输编码和分块编码

区别于内容编码（内容编码是和内容的具体格式紧密相关），传输编码与格式无关，而是为了改变报文的传输方式。

Transfer-Encoding
- 告知接收方为了可靠地传输报文，已经对其进行的编码方式。（编码方式必须包含分块编码方式）
TE
- 用在请求首部，告知服务器可以使用哪些传输编码扩展（含义相当于是说 Accept-Transfer-Encoding）

举例：

- 请求：`TE: trailers, chunked`，chunked 代表支持分块编码， trailer 代表支持拖挂
- 响应：`Transfer-Encoding: chunked Traniler: Content-MD5`

分块编码就是一种传输编码方式，是指把报文分割成若干大小已知的块，会依次发送，这样就不需要发送之前知道整个报文的大小。
分块编码可以解决持久连接的情况下，服务器动态创建内容，无法提前知道主体长度的问题。
使用分块的时候，必须最后一个作用于报文主体（就是说别的各种处理先处理完了，最后再分块），而且不能重复对分块的报文继续分块。

拖挂是指某些首部无法提前确定，需要主体生成完了才能确认，那就只能最后发送。

### 缓存相关（在第4章已经有详细介绍）

**新鲜度** 内容能缓存多长时间。

- Expires：过期时间
- Cache-Control：缓存控制

**条件请求** ：资源改变时才进行请求

- If-Modified-Since: 以 Last-Modified 作为验证码
- If-Unmodified-Since： 以 Last-Modified 作为验证码
- If-Match：以 ETag 作为验证码
- If-None-Match：以 ETag 作为验证码

**验证码**：用来验证条件请求的条件是否满足的文档属性

- Last-Modified：与上述 If-Modified-Since 和 If-Unmodified-Since配合使用
- ETag: 与上述 If-Match 和 If-None-Match 配合使用

### 范围请求

- Range：客户端可以只请求文档的一部分，用来应对下载中断后，继续下载剩余部分的这种情况。比如点对点的文件共享客户端应用。
举例：`Range: byte=4000-` 代表下载4000字节之后的东西。
- Accept-Ranges: 服务端声明自己可以接收的范围请求的单位
举例：`Accept-Range: bytes` 代表以字节为单位计算。

### 差异编码

只发送文档改变的部分，相关的首部：

- ETag
- If-None-Match
- A-IM：客户端说明可以接受的实例操控类型
- IM：服务器说明在响应上的实例操控类型
- Delta-Base：服务说明用于计算差异的基线文档的 ETag 值

### 其他常见首部

- Content-Language：传送对象的语言
- Content-Location：备用位置，请求时可以用这个路径获得请求对象
- Content-Range：说明范围请求到的部分实体属于整体的哪个部分
- Content-MD5：实体主体内容的校验和
- Allow：允许的请求方法